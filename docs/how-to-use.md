# How to use

Basic example:

```python
>>> from flocs import actions
>>> from flocs.store import Store
>>> from flocs.state import default_dynamic

>>> # create a store by specifying initial state and optionally a context
>>> store = Store(state=default_dynamic)

>>> # create an action (new IDs are autogenerated)
>>> a1 = actions.create(type='start-session', data={})
>>> student_id = a1.data.student_id

>>> # stage action (returns action with added context)
>>> store.stage_action(a1)
Action(action_id=UUID(...), type='start-session', ...)

>>> # create and stage another action
>>> a2 = actions.create(type='start-task', data={'student-id': student_id, 'task-id': 'three-steps-forward'})
>>> store.stage_action(a2)
Action(action_id=UUID(...), type='start-task', ...)

>>> # current state is computed on demand by applying all staged actions to initial state
>>> print(store.state.task_sessions)
TaskSession entities:
* TaskSession(task_session_id=UUID('...'), student_id=UUID('...'), task_id='three-steps-forward', solved=False, ...)

>>> # entity maps can by filtered and ordered
>>> print(store.state.actions.order_by('time'))
Action entities:
* Action(action_id=UUID(...), type='start-session', ...)
* Action(action_id=UUID(...), type='start-task', ...)

```

## Persistence

1. First, specify how to load entities you want to work with.
   Flocs provides `flocs.entity_map.EntityMap`, but you can use your own implementation of entity map,
   e.g. as an adapter over a DB, just make sure to satisfy EntityMap protocol
   (= collections.abc.Mapping protocol, immutable `set`, Django-like `filter` and `order_by`).
   Test your implementation using inheritable `flocs.tests.test_entity_map.TestEntityMap`.

    ```python
    >>> from flocs.entities import Action, Task, Student, TaskSession
    >>> from flocs.state import State
    >>> from flocs.context import dynamic
    >>> from flocs.entity_map import EntityMap

    >>> def my_entity_map(entity_class):
    ...     return EntityMap()  # use your own implementation

    >>> my_entities = {
    ...   entity_class: my_entity_map(entity_class)
    ...   for entity_class in [Action, Task, Student, TaskSession]
    ... }
    >>> my_state = State(entities=my_entities).add_context(dynamic)

    ```

2. Then you need to specify how to store new state.
   You can use `post_commit` hook which is called after each commit in the store.

    ```python
    >>> from flocs.store import Store

    >>> class PersistenceHooks(Store.Hooks):
    ...    def post_commit(self, state, diff):
    ...        pass  # save new state

    ```

3. Finally, use `Store.open()` context manager which creates state at the beginning of the `with` block
   and commits all staged actions at the end of the block.

    ```python
    >>> from flocs import actions
    >>> from flocs.store import Store

    >>> with Store.open(my_state, hooks=PersistenceHooks()) as store:
    ...     action = actions.create(type='start-session', data={})
    ...     store.stage_action(action)
    Action(action_id=UUID(...), type='start-session', ...)

    ```

### Tips

* As you are likely to use the same state creator and hooks together many times, you may wish to factor out the creation of store context manager into a separate function:

    ```python
    def open_my_persistent_store():
        return Store.open(my_state, hooks=PersistenceHooks())

    with open_my_persistent_store() as store:
        action = actions.create(type='solve-task', data={'task-session-id': 25})
        store.stage_action(action)
    ```

* If your persistent state is shared by several threads (e.g. web application), then it is probably good idea to wrap your store operations in an atomic context to avoid inconsistencies.
